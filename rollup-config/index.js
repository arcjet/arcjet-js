/**
 * @import {Dirent} from "node:fs";
 * @import {Plugin, RollupOptions} from "rollup";
 * @import {type runTranspileComponent as RunTranspileComponent} from "@bytecodealliance/jco-transpile/src/transpile.js";
 */

/**
 * @typedef Options
 *   Configuration.
 * @property {ReadonlyArray<Plugin> | undefined} [plugins]
 *   Additional plugins to use in the Rollup configuration.
 */

/**
 * @typedef TranspileComponentOptions
 *   Main parameter of `transpile`, which is not typed/exposed correctly.
 *   This does end up in `.d.ts` so we it is typed here manually.
 * @property {ReadonlyArray<string> | null | undefined} [asyncImports]
 * @property {ReadonlyArray<string> | null | undefined} [asyncExports]
 * @property {string | null | undefined} [asyncMode]
 * @property {ReadonlyArray<string> | 'all' | null | undefined} [features]
 * @property {boolean | null | undefined} [guest]
 * @property {'async' | 'sync' | null | undefined} [instantiation]
 * @property {string | null | undefined} [name]
 * @property {string | null | undefined} [outDir]
 * @property {boolean | null | undefined} [tlaCompat]
 * @property {string | null | undefined} [worldName]
 */

import { mkdir, writeFile } from "node:fs/promises";
import fs from "node:fs";
import path from "node:path";
import { fileURLToPath, pathToFileURL } from "node:url";
import { isBuiltin } from "node:module";
import { transpile } from "@bytecodealliance/jco-transpile";
import replace from "@rollup/plugin-replace";
import typescript from "@rollup/plugin-typescript";

/**
 * @param {Buffer} wasm
 * @returns {string}
 */
function generateJs(wasm) {
  const disclaimer = `
/**
 * This file contains an Arcjet Wasm binary inlined as a base64
 * [Data URL](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URLs)
 * with the application/wasm MIME type.
 *
 * This was chosen to save on storage space over inlining the file directly as
 * a Uint8Array, which would take up ~3x the space of the Wasm file. See
 * https://blobfolio.com/2019/better-binary-batter-mixing-base64-and-uint8array/
 * for more details.
 *
 * It is then decoded into an ArrayBuffer to be used directly via WebAssembly's
 * \`compile()\` function in our entry point file.
 *
 * This is all done to avoid trying to read or bundle the Wasm asset in various
 * ways based on the platform or bundler a user is targeting. One example being
 * that Next.js requires special \`asyncWebAssembly\` webpack config to load our
 * Wasm file if we don't do this.
 *
 * In the future, we hope to do away with this workaround when all bundlers
 * properly support consistent asset bundling techniques.
 */
`;

  return `// @generated by wasm2module - DO NOT EDIT
/* eslint-disable */
// @ts-nocheck
${disclaimer}
const wasmBase64 = "data:application/wasm;base64,${wasm.toString("base64")}";
/**
 * Returns a WebAssembly.Module for an Arcjet Wasm binary, decoded from a base64
 * Data URL.
 */
// TODO: Switch back to top-level await when our platforms all support it
export async function wasm() {
  // This uses fetch to decode the wasm data url, but disabling cache so files
  // larger than 2mb don't fail to parse in the Next.js App Router
  const wasmDecode = await fetch(wasmBase64, { cache: "no-store" });
  const buf = await wasmDecode.arrayBuffer();
  // And then we return it as a WebAssembly.Module
  return WebAssembly.compile(buf);
}
`;
}

/**
 * @returns {Plugin}}
 */
function wasmToModule() {
  const idToWasmPath = new Map();

  return {
    name: "base64-wasm",
    resolveId(source) {
      if (source.endsWith(".wasm?js")) {
        // Slice off the `?js` to make it a valid path
        const filepath = source.slice(0, -3);
        // Create a "virtual module", prefixed with `\0` as per the Rollup docs,
        // for our replacement import
        const id = `\0${filepath.replace(/\.wasm$/, ".js")}`;
        // Store the actual Wasm path against the virtual module ID.
        idToWasmPath.set(id, filepath);
        return id;
      }

      return null;
    },
    async load(id) {
      const wasmPath = idToWasmPath.get(id);
      // If we resolved this `id` during the `resolveId` phase, generate the
      // JavaScript file with the base64 Wasm and loading helper
      if (wasmPath) {
        const wasm = await fs.promises.readFile(wasmPath);
        return generateJs(wasm);
      }

      return null;
    },
  };
}

/**
 * @param {string} filename
 *   File name.
 * @returns {string}
 *   File name without extension.
 */
function removeExtension(filename) {
  return path.basename(filename, path.extname(filename));
}

/**
 * @param {Dirent} file
 * @returns {boolean}
 */
function isTypeScript(file) {
  return (
    file.isFile() && file.name.endsWith(".ts") && !file.name.endsWith(".d.ts")
  );
}

/**
 * Create Rollup configuration for bundling TypeScript files in the Arcjet SDK.
 *
 * @param {string} root
 *   Folder.
 * @param {Options | undefined} [options]
 *   Configuration.
 * @returns {RollupOptions}
 *   Rollup configuration object.
 */
export function createConfig(root, options) {
  const settings = options || {};
  const plugins = settings.plugins || [];
  const packageJson = fileURLToPath(new URL("./package.json", root));
  const pkg = JSON.parse(fs.readFileSync(packageJson, "utf8"));
  const dependencies = Object.keys(pkg.dependencies ?? {});
  const devDependencies = Object.keys(pkg.devDependencies ?? {});
  const peerDependencies = Object.keys(pkg.peerDependencies ?? {});

  /**
   * @param {string} id
   * @returns {boolean}
   */
  function isDependency(id) {
    return dependencies.some((dep) => id.startsWith(dep));
  }

  /**
   * @param {string} id
   * @returns {boolean}
   */
  function isDevDependency(id) {
    return devDependencies.some((dep) => id.startsWith(dep));
  }

  /**
   * @param {string} id
   * @returns {boolean}
   */
  function isPeerDependency(id) {
    return peerDependencies.some((dep) => id.startsWith(dep));
  }

  /**
   * @param {string} id
   * @returns {boolean}
   */
  function isBunBuiltin(id) {
    return id === "bun";
  }

  /**
   * @param {string} id
   * @returns {boolean}
   */
  function isSvelteKitBuiltin(id) {
    return id === "$env/dynamic/private";
  }

  const rootDir = fileURLToPath(new URL(".", root));
  const testDir = fileURLToPath(new URL("test/", root));

  const typescriptDirs = [rootDir, testDir];

  /**
   * Create a Rollup input entry that can be used with `Object.fromEntries()`.
   *
   * @param {Dirent} file
   * @returns {[entryName: string, filePath: string]}
   */
  function toEntry(file) {
    // @ts-expect-error:
    // Node lower than 18 used `path` which is now removed in favor of
    // `parentPath`.
    // See: <https://nodejs.org/api/deprecations.html#dep0178-direntpath>.
    const parentPath = file.parentPath || file.path;
    return [
      path.relative(rootDir, `${parentPath}${removeExtension(file.name)}`),
      path.relative(rootDir, `${parentPath}${file.name}`),
    ];
  }

  // Find all TypeScript files in the specified directories
  const input = Object.fromEntries(
    typescriptDirs.flatMap((dir) => {
      // All the directories might not exist in every project
      try {
        const files = fs.readdirSync(dir, { withFileTypes: true });
        return files.filter(isTypeScript).map(toEntry);
      } catch {
        return [];
      }
    }),
  );

  return {
    input,
    output: {
      dir: ".",
      format: "es",
      // Hoist transitive imports for faster loading. For more details, see
      // https://rollupjs.org/faqs/#why-do-additional-imports-turn-up-in-my-entry-chunks-when-code-splitting
      hoistTransitiveImports: true,
      // Stop rollup from creating additional chunks that it thinks we need
      preserveModules: true,
    },
    external(id) {
      return (
        isBuiltin(id) ||
        isDependency(id) ||
        isDevDependency(id) ||
        isPeerDependency(id) ||
        isBunBuiltin(id) ||
        isSvelteKitBuiltin(id)
      );
    },
    plugins: [
      // Replace always comes first to ensure the replaced values exist for all
      // other plugins
      replace({
        values: {
          // We always replace `__ARCJET_SDK_VERSION__` based on the version
          // in package.json
          __ARCJET_SDK_VERSION__: pkg.version,
        },
        preventAssignment: true,
      }),
      typescript({
        tsconfig: "./tsconfig.json",
        // Override the `excludes` specified in the tsconfig so we don't
        // generate definition files for our tests
        exclude: ["node_modules", "test/*.ts"],
        declaration: true,
        declarationDir: ".",
        noEmitOnError: true,
      }),
      typescript({
        tsconfig: "./tsconfig.json",
        // Override the `includes` specified in the tsconfig so we don't
        // generate definition files for our tests
        include: "test/*.ts",
        noEmitOnError: true,
      }),
      {
        name: "externalize-wasm",
        resolveId(id) {
          // Vercel uses the `.wasm?module` suffix to make WebAssembly available
          // in their Vercel Functions product.
          // https://vercel.com/docs/functions/wasm#using-a-webassembly-file
          //
          // The Cloudflare docs say they support the `.wasm?module` suffix, but
          // that seems to no longer be the case with Wrangler 2 so we need to
          // have separate imports for just the `.wasm` files.
          //
          // https://developers.cloudflare.com/workers/runtime-apis/webassembly/javascript/#bundling
          if (id.endsWith(".wasm") || id.endsWith(".wasm?module")) {
            return { id, external: true };
          }
          return null;
        },
      },
      wasmToModule(),
      ...plugins,
    ],
  };
}

/**
 * Create a Rollup plugin that turns a WebAssembly component into JavaScript
 * and `.d.ts` files.
 *
 * @param {URL | string} url
 *   File URL to input WebAssembly file (**required**).
 * @param {TranspileComponentOptions} options
 *   Configuration (**required**).
 * @returns {Plugin}
 *   Plugin.
 */
export function transpileComponent(url, options) {
  return {
    buildStart: {
      async handler() {
        /**
         * Return type of `transpile`, which is not typed or exposed correctly.
         * It works in this file as it doesn’t end up in `.d.ts`.
         *
         * @type {ReturnType<RunTranspileComponent> extends Promise<infer T> ? T : never}
         */
        const result = await transpile(fileURLToPath(url), options);

        for (const [path, value] of Object.entries(result.files)) {
          const url = pathToFileURL(path);
          await mkdir(new URL(".", url), { recursive: true });
          await writeFile(path, value);
          // eslint-disable-next-line no-undef -- console exists.
          console.log(` + ${path} (${value.length / 1000} kB)`);
        }
      },
      // Has to use `pre` otherwise TypeScript hangs indefinitely.
      order: "pre",
      // Has to be sequential otherwise TypeScript hangs indefinitely.
      sequential: true,
    },
    name: "jco",
    version: "0.0.0",
  };
}

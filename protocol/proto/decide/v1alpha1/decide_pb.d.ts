// @generated by protoc-gen-es v2.2.0
// @generated from file proto/decide/v1alpha1/decide.proto (package proto.decide.v1alpha1, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv1";
import type { Message } from "@bufbuild/protobuf";
import type { Timestamp } from "@bufbuild/protobuf/wkt";

/**
 * Describes the file proto/decide/v1alpha1/decide.proto.
 */
export declare const file_proto_decide_v1alpha1_decide: GenFile;

/**
 * Additional information from Arcjet about the IP address associated with a
 * request.
 *
 * @generated from message proto.decide.v1alpha1.IpDetails
 */
export declare type IpDetails = Message<"proto.decide.v1alpha1.IpDetails"> & {
  /**
   * The estimated latitude of the IP address - see accuracy_radius for the
   * margin of error.
   *
   * @generated from field: double latitude = 1;
   */
  latitude: number;

  /**
   * The estimated longitude of the IP address - see accuracy_radius for the
   * margin of error.
   *
   * @generated from field: double longitude = 2;
   */
  longitude: number;

  /**
   * The accuracy radius of the IP address location in kilometers.
   *
   * @generated from field: int32 accuracy_radius = 3;
   */
  accuracyRadius: number;

  /**
   * The timezone of the IP address.
   *
   * @generated from field: string timezone = 4;
   */
  timezone: string;

  /**
   * The postal code of the IP address.
   *
   * @generated from field: string postal_code = 5;
   */
  postalCode: string;

  /**
   * The city the IP address is located in.
   *
   * @generated from field: string city = 6;
   */
  city: string;

  /**
   * The region the IP address is located in.
   *
   * @generated from field: string region = 7;
   */
  region: string;

  /**
   * The country code the IP address is located in.
   *
   * @generated from field: string country = 8;
   */
  country: string;

  /**
   * The country name the IP address is located in.
   *
   * @generated from field: string country_name = 9;
   */
  countryName: string;

  /**
   * The continent code the IP address is located in.
   *
   * @generated from field: string continent = 10;
   */
  continent: string;

  /**
   * The continent name the IP address is located in.
   *
   * @generated from field: string continent_name = 11;
   */
  continentName: string;

  /**
   * The AS number the IP address belongs to.
   *
   * @generated from field: string asn = 12;
   */
  asn: string;

  /**
   * The AS name the IP address belongs to.
   *
   * @generated from field: string asn_name = 13;
   */
  asnName: string;

  /**
   * The AS domain the IP address belongs to.
   *
   * @generated from field: string asn_domain = 14;
   */
  asnDomain: string;

  /**
   * The ASN type: ISP, hosting, business, or education
   *
   * @generated from field: string asn_type = 15;
   */
  asnType: string;

  /**
   * The ASN country code the IP address belongs to.
   *
   * @generated from field: string asn_country = 16;
   */
  asnCountry: string;

  /**
   * The name of the service the IP address belongs to.
   *
   * @generated from field: string service = 17;
   */
  service: string;

  /**
   * Whether the IP address belongs to a hosting provider.
   *
   * @generated from field: bool is_hosting = 18;
   */
  isHosting: boolean;

  /**
   * Whether the IP address belongs to a VPN provider.
   *
   * @generated from field: bool is_vpn = 19;
   */
  isVpn: boolean;

  /**
   * Whether the IP address belongs to a proxy provider.
   *
   * @generated from field: bool is_proxy = 20;
   */
  isProxy: boolean;

  /**
   * Whether the IP address belongs to a Tor node.
   *
   * @generated from field: bool is_tor = 21;
   */
  isTor: boolean;

  /**
   * Whether the IP address belongs to a relay service.
   *
   * @generated from field: bool is_relay = 22;
   */
  isRelay: boolean;
};

/**
 * Describes the message proto.decide.v1alpha1.IpDetails.
 * Use `create(IpDetailsSchema)` to create a new message.
 */
export declare const IpDetailsSchema: GenMessage<IpDetails>;

/**
 * The reason for the decision. This is populated based on the selected rules
 * for deny or challenge responses. Additional details can be found in the field
 * and by logging into the Arcjet dashboard and searching for the decision ID.
 *
 * @generated from message proto.decide.v1alpha1.Reason
 */
export declare type Reason = Message<"proto.decide.v1alpha1.Reason"> & {
  /**
   * @generated from oneof proto.decide.v1alpha1.Reason.reason
   */
  reason: {
    /**
     * Contains details about the rate limit when the decision was made
     * based on a rate limit rule.
     *
     * @generated from field: proto.decide.v1alpha1.RateLimitReason rate_limit = 1;
     */
    value: RateLimitReason;
    case: "rateLimit";
  } | {
    /**
     * Contains details about the edge rules which were triggered when the
     * decision was made based on an edge rule.
     *
     * @generated from field: proto.decide.v1alpha1.EdgeRuleReason edge_rule = 2;
     */
    value: EdgeRuleReason;
    case: "edgeRule";
  } | {
    /**
     * Contains details about why the request was considered a bot when the
     * decision was made based on a bot rule.
     *
     * @generated from field: proto.decide.v1alpha1.BotReason bot = 3;
     */
    value: BotReason;
    case: "bot";
  } | {
    /**
     * Contains details about why Arcjet Shield was triggered.
     *
     * @generated from field: proto.decide.v1alpha1.ShieldReason shield = 4;
     */
    value: ShieldReason;
    case: "shield";
  } | {
    /**
     * Contains details about the email when the decision was made based on
     * an email rule.
     *
     * @generated from field: proto.decide.v1alpha1.EmailReason email = 5;
     */
    value: EmailReason;
    case: "email";
  } | {
    /**
     * Contains details about the error decision when an error occurred.
     *
     * @generated from field: proto.decide.v1alpha1.ErrorReason error = 6;
     */
    value: ErrorReason;
    case: "error";
  } | {
    /**
     * Contains details about sensitive info identified in the body of the
     * request if the sensitive info rule is configured.
     *
     * @generated from field: proto.decide.v1alpha1.SensitiveInfoReason sensitive_info = 7;
     */
    value: SensitiveInfoReason;
    case: "sensitiveInfo";
  } | {
    /**
     * Contains details about why the request was considered a bot when the
     * decision was made based on a bot (v2) rule.
     *
     * @generated from field: proto.decide.v1alpha1.BotV2Reason bot_v2 = 8;
     */
    value: BotV2Reason;
    case: "botV2";
  } | {
    /**
     * Contains details about the filter rules which were triggered when the
     * decision was made based on a filter rule.
     *
     * @generated from field: proto.decide.v1alpha1.FilterReason filter = 9;
     */
    value: FilterReason;
    case: "filter";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message proto.decide.v1alpha1.Reason.
 * Use `create(ReasonSchema)` to create a new message.
 */
export declare const ReasonSchema: GenMessage<Reason>;

/**
 * Details of a rate limit decision.
 *
 * @generated from message proto.decide.v1alpha1.RateLimitReason
 */
export declare type RateLimitReason = Message<"proto.decide.v1alpha1.RateLimitReason"> & {
  /**
   * The configured maximum number of requests allowed in the current window.
   *
   * @generated from field: uint32 max = 1;
   */
  max: number;

  /**
   * Deprecated: Always empty. Previously, the number of requests which have
   * been made in the current window.
   *
   * @generated from field: int32 count = 2 [deprecated = true];
   * @deprecated
   */
  count: number;

  /**
   * The number of requests remaining in the current window.
   *
   * @generated from field: uint32 remaining = 3;
   */
  remaining: number;

  /**
   * The time at which the rate limit window will reset.
   *
   * Deprecated: Use `reset_in_seconds` instead.
   *
   * @generated from field: google.protobuf.Timestamp reset_time = 4 [deprecated = true];
   * @deprecated
   */
  resetTime?: Timestamp;

  /**
   * The duration in seconds until this rate limit window will reset.
   *
   * @generated from field: uint32 reset_in_seconds = 5;
   */
  resetInSeconds: number;

  /**
   * The time window in seconds of this rate limit.
   *
   * @generated from field: uint32 window_in_seconds = 6;
   */
  windowInSeconds: number;
};

/**
 * Describes the message proto.decide.v1alpha1.RateLimitReason.
 * Use `create(RateLimitReasonSchema)` to create a new message.
 */
export declare const RateLimitReasonSchema: GenMessage<RateLimitReason>;

/**
 * Details of an edge rule decision. Unimplemented.
 *
 * @generated from message proto.decide.v1alpha1.EdgeRuleReason
 */
export declare type EdgeRuleReason = Message<"proto.decide.v1alpha1.EdgeRuleReason"> & {
};

/**
 * Describes the message proto.decide.v1alpha1.EdgeRuleReason.
 * Use `create(EdgeRuleReasonSchema)` to create a new message.
 */
export declare const EdgeRuleReasonSchema: GenMessage<EdgeRuleReason>;

/**
 * Details of a bot decision.
 *
 * @generated from message proto.decide.v1alpha1.BotReason
 */
export declare type BotReason = Message<"proto.decide.v1alpha1.BotReason"> & {
  /**
   * The bot type we detected. See `BotType` for more information.
   *
   * @generated from field: proto.decide.v1alpha1.BotType bot_type = 1;
   */
  botType: BotType;

  /**
   * The bot score we calculated. Score ranges from 0 to 99 representing the
   * degree of certainty. The higher the number within the type category, the
   * greater the degree of certainty. See `BotType` for more information.
   *
   * @generated from field: int32 bot_score = 2;
   */
  botScore: number;

  /**
   * Whether bot detection was triggered by our user agent matching.
   *
   * @generated from field: bool user_agent_match = 3;
   */
  userAgentMatch: boolean;

  /**
   * Whether the IP address belongs to a hosting provider.
   *
   * @generated from field: bool ip_hosting = 5;
   */
  ipHosting: boolean;

  /**
   * Whether the IP address belongs to a VPN provider.
   *
   * @generated from field: bool ip_vpn = 6;
   */
  ipVpn: boolean;

  /**
   * Whether the IP address belongs to a proxy provider.
   *
   * @generated from field: bool ip_proxy = 7;
   */
  ipProxy: boolean;

  /**
   * Whether the IP address belongs to a Tor node.
   *
   * @generated from field: bool ip_tor = 8;
   */
  ipTor: boolean;

  /**
   * Whether the IP address belongs to a relay service.
   *
   * @generated from field: bool ip_relay = 9;
   */
  ipRelay: boolean;
};

/**
 * Describes the message proto.decide.v1alpha1.BotReason.
 * Use `create(BotReasonSchema)` to create a new message.
 */
export declare const BotReasonSchema: GenMessage<BotReason>;

/**
 * Details of a bot (v2) decision.
 *
 * @generated from message proto.decide.v1alpha1.BotV2Reason
 */
export declare type BotV2Reason = Message<"proto.decide.v1alpha1.BotV2Reason"> & {
  /**
   * @generated from field: repeated string allowed = 1;
   */
  allowed: string[];

  /**
   * @generated from field: repeated string denied = 2;
   */
  denied: string[];

  /**
   * @generated from field: bool verified = 3;
   */
  verified: boolean;

  /**
   * @generated from field: bool spoofed = 4;
   */
  spoofed: boolean;
};

/**
 * Describes the message proto.decide.v1alpha1.BotV2Reason.
 * Use `create(BotV2ReasonSchema)` to create a new message.
 */
export declare const BotV2ReasonSchema: GenMessage<BotV2Reason>;

/**
 * Details of an Arcjet Shield decision.
 *
 * @generated from message proto.decide.v1alpha1.ShieldReason
 */
export declare type ShieldReason = Message<"proto.decide.v1alpha1.ShieldReason"> & {
  /**
   * Whether Arcjet Shield was triggered. Log into the Arcjet dashboard and
   * search for the decision ID to find more details about which rules were
   * triggered.
   *
   * @generated from field: bool shield_triggered = 1;
   */
  shieldTriggered: boolean;

  /**
   * Whether the request was considered suspicious based on background
   * analysis of the request
   *
   * @generated from field: bool suspicious = 2;
   */
  suspicious: boolean;
};

/**
 * Describes the message proto.decide.v1alpha1.ShieldReason.
 * Use `create(ShieldReasonSchema)` to create a new message.
 */
export declare const ShieldReasonSchema: GenMessage<ShieldReason>;

/**
 * Details of an Arcjet Filter decision.
 *
 * @generated from message proto.decide.v1alpha1.FilterReason
 */
export declare type FilterReason = Message<"proto.decide.v1alpha1.FilterReason"> & {
  /**
   * Deprecated: Use the `matched_expressions` field instead.
   *
   * @generated from field: string matched_expression = 1 [deprecated = true];
   * @deprecated
   */
  matchedExpression: string;

  /**
   * List of all matched expressions.
   *
   * @generated from field: repeated string matched_expressions = 2;
   */
  matchedExpressions: string[];

  /**
   * List of all undetermined expressions.
   *
   * @generated from field: repeated string undetermined_expressions = 3;
   */
  undeterminedExpressions: string[];
};

/**
 * Describes the message proto.decide.v1alpha1.FilterReason.
 * Use `create(FilterReasonSchema)` to create a new message.
 */
export declare const FilterReasonSchema: GenMessage<FilterReason>;

/**
 * Details of an email decision.
 *
 * @generated from message proto.decide.v1alpha1.EmailReason
 */
export declare type EmailReason = Message<"proto.decide.v1alpha1.EmailReason"> & {
  /**
   * The types of email address we detected. This may be one or more of the
   * `EmailType` values.
   *
   * @generated from field: repeated proto.decide.v1alpha1.EmailType email_types = 1;
   */
  emailTypes: EmailType[];
};

/**
 * Describes the message proto.decide.v1alpha1.EmailReason.
 * Use `create(EmailReasonSchema)` to create a new message.
 */
export declare const EmailReasonSchema: GenMessage<EmailReason>;

/**
 * Details of an error decision.
 *
 * @generated from message proto.decide.v1alpha1.ErrorReason
 */
export declare type ErrorReason = Message<"proto.decide.v1alpha1.ErrorReason"> & {
  /**
   * The error message associated with the error decision.
   *
   * @generated from field: string message = 1;
   */
  message: string;
};

/**
 * Describes the message proto.decide.v1alpha1.ErrorReason.
 * Use `create(ErrorReasonSchema)` to create a new message.
 */
export declare const ErrorReasonSchema: GenMessage<ErrorReason>;

/**
 * @generated from message proto.decide.v1alpha1.IdentifiedEntity
 */
export declare type IdentifiedEntity = Message<"proto.decide.v1alpha1.IdentifiedEntity"> & {
  /**
   * The type of entity that was identified
   *
   * @generated from field: string identified_type = 1;
   */
  identifiedType: string;

  /**
   * The start index of the entity in the body.
   *
   * @generated from field: uint32 start = 2;
   */
  start: number;

  /**
   * The end index of the entity in the body.
   *
   * @generated from field: uint32 end = 3;
   */
  end: number;
};

/**
 * Describes the message proto.decide.v1alpha1.IdentifiedEntity.
 * Use `create(IdentifiedEntitySchema)` to create a new message.
 */
export declare const IdentifiedEntitySchema: GenMessage<IdentifiedEntity>;

/**
 * Details of a sensitive info reason.
 *
 * @generated from message proto.decide.v1alpha1.SensitiveInfoReason
 */
export declare type SensitiveInfoReason = Message<"proto.decide.v1alpha1.SensitiveInfoReason"> & {
  /**
   * The allowed sensitive info types
   *
   * @generated from field: repeated proto.decide.v1alpha1.IdentifiedEntity allowed = 1;
   */
  allowed: IdentifiedEntity[];

  /**
   * The denied sensitive info types
   *
   * @generated from field: repeated proto.decide.v1alpha1.IdentifiedEntity denied = 2;
   */
  denied: IdentifiedEntity[];
};

/**
 * Describes the message proto.decide.v1alpha1.SensitiveInfoReason.
 * Use `create(SensitiveInfoReasonSchema)` to create a new message.
 */
export declare const SensitiveInfoReasonSchema: GenMessage<SensitiveInfoReason>;

/**
 * The configuration for a rate limit rule.
 *
 * @generated from message proto.decide.v1alpha1.RateLimitRule
 */
export declare type RateLimitRule = Message<"proto.decide.v1alpha1.RateLimitRule"> & {
  /**
   * @generated from field: proto.decide.v1alpha1.Mode mode = 1;
   */
  mode: Mode;

  /**
   * The request path the rate limit applies to. If not specified and Arcjet
   * is running on a specific API route, it defaults to the path for that
   * route. If not specified and Arcjet is running from middleware, it applies
   * to all routes.
   *
   * @generated from field: string match = 2;
   */
  match: string;

  /**
   * Defines how Arcjet will track rate limits. If none are specified, it will
   * default to using the client IP address. If more than one characteristic
   * is provided, they will be combined. For further details, see
   * https://docs.arcjet.com/architecture/#fingerprinting
   *
   * @generated from field: repeated string characteristics = 3;
   */
  characteristics: string[];

  /**
   * The time window the rate limit applies to. This is a string value with a
   * sequence of decimal numbers, each with an optional fraction and a unit
   * suffix e.g. 1s for 1 second, 1h45m for 1 hour and 45 minutes, 1d for 1
   * day. Valid time units are ns, us (or µs), ms, s, m, h.
   *
   * Deprecated: Use the window_in_seconds field instead.
   *
   * @generated from field: string window = 4 [deprecated = true];
   * @deprecated
   */
  window: string;

  /**
   * The maximum number of requests allowed in the time period. This is a
   * positive integer value e.g. 100.
   *
   * Required by "fixed window", "sliding window", and unspecified algorithms.
   *
   * @generated from field: uint32 max = 5;
   */
  max: number;

  /**
   * How long to apply the limit before it expires and the client is allowed
   * to make more requests. If not specified, this will default to the same
   * value as the Window e.g. if the window is 1 hour, the client will be rate
   * limited for 1 hour after they hit the limit. This is a string value with
   * a sequence of decimal numbers, each with an optional fraction and a unit
   * suffix e.g. 1s for 1 second, 1h45m for 1 hour and 45 minutes, 1d for 1
   * day. Valid time units are ns, us (or µs), ms, s, m, h, d, w, y.
   *
   * @generated from field: string timeout = 6;
   */
  timeout: string;

  /**
   * The algorithm to use for rate limiting a request. If unspecified, we will
   * fallback to the "fixed window" algorithm. The chosen algorithm will
   * affect which other fields must be specified to be a valid configuration.
   *
   * @generated from field: proto.decide.v1alpha1.RateLimitAlgorithm algorithm = 7;
   */
  algorithm: RateLimitAlgorithm;

  /**
   * The amount of tokens that are refilled at the provided interval.
   *
   * Required by "token bucket" algorithm.
   *
   * @generated from field: uint32 refill_rate = 8;
   */
  refillRate: number;

  /**
   * The interval in which a rate limit is applied or tokens refilled.
   *
   * Required by "token bucket" and "sliding window" algorithms.
   *
   * @generated from field: uint32 interval = 9;
   */
  interval: number;

  /**
   * The maximum number of tokens that can exist in a token bucket.
   *
   * Required by "token bucket" algorithm.
   *
   * @generated from field: uint32 capacity = 10;
   */
  capacity: number;

  /**
   * The time window the rate limit applies to. This is an unsigned 32-bit
   * integer value representing a number of seconds.
   *
   * Required by "fixed window" and unspecified algorithms.
   *
   * @generated from field: uint32 window_in_seconds = 12;
   */
  windowInSeconds: number;

  /**
   * The version of the rule being executed. This is incremented by SDKs when
   * a breaking change is made to the configuration or behavior of the rule.
   *
   * @generated from field: proto.decide.v1alpha1.RateLimitRuleVersion version = 13;
   */
  version: RateLimitRuleVersion;
};

/**
 * Describes the message proto.decide.v1alpha1.RateLimitRule.
 * Use `create(RateLimitRuleSchema)` to create a new message.
 */
export declare const RateLimitRuleSchema: GenMessage<RateLimitRule>;

/**
 * The configuration for a bot rule.
 *
 * @generated from message proto.decide.v1alpha1.BotRule
 */
export declare type BotRule = Message<"proto.decide.v1alpha1.BotRule"> & {
  /**
   * @generated from field: proto.decide.v1alpha1.Mode mode = 1;
   */
  mode: Mode;

  /**
   * The bot types to block. This may be one or more of the `BotType` values.
   *
   * @generated from field: repeated proto.decide.v1alpha1.BotType block = 2;
   */
  block: BotType[];

  /**
   * Additional bot detection rules to add or remove from the Arcjet standard
   * list. Each rule is a regular expression that matches the user agent of
   * the bot plus a label to indicate what type of bot it is from the above
   * `BotType`s.
   *
   * @generated from field: proto.decide.v1alpha1.BotRule.Patterns patterns = 3;
   */
  patterns?: BotRule_Patterns;
};

/**
 * Describes the message proto.decide.v1alpha1.BotRule.
 * Use `create(BotRuleSchema)` to create a new message.
 */
export declare const BotRuleSchema: GenMessage<BotRule>;

/**
 * @generated from message proto.decide.v1alpha1.BotRule.Patterns
 */
export declare type BotRule_Patterns = Message<"proto.decide.v1alpha1.BotRule.Patterns"> & {
  /**
   * @generated from field: map<string, proto.decide.v1alpha1.BotType> add = 1;
   */
  add: { [key: string]: BotType };

  /**
   * @generated from field: repeated string remove = 2;
   */
  remove: string[];
};

/**
 * Describes the message proto.decide.v1alpha1.BotRule.Patterns.
 * Use `create(BotRule_PatternsSchema)` to create a new message.
 */
export declare const BotRule_PatternsSchema: GenMessage<BotRule_Patterns>;

/**
 * The configuration for a bot (v2) rule.
 *
 * @generated from message proto.decide.v1alpha1.BotV2Rule
 */
export declare type BotV2Rule = Message<"proto.decide.v1alpha1.BotV2Rule"> & {
  /**
   * @generated from field: proto.decide.v1alpha1.Mode mode = 1;
   */
  mode: Mode;

  /**
   * @generated from field: repeated string allow = 2;
   */
  allow: string[];

  /**
   * @generated from field: repeated string deny = 3;
   */
  deny: string[];

  /**
   * The version of the rule being executed. This is incremented by SDKs when
   * a breaking change is made to the configuration or behavior of the rule.
   *
   * @generated from field: proto.decide.v1alpha1.BotV2RuleVersion version = 4;
   */
  version: BotV2RuleVersion;
};

/**
 * Describes the message proto.decide.v1alpha1.BotV2Rule.
 * Use `create(BotV2RuleSchema)` to create a new message.
 */
export declare const BotV2RuleSchema: GenMessage<BotV2Rule>;

/**
 * The configuration for an email rule.
 *
 * @generated from message proto.decide.v1alpha1.EmailRule
 */
export declare type EmailRule = Message<"proto.decide.v1alpha1.EmailRule"> & {
  /**
   * @generated from field: proto.decide.v1alpha1.Mode mode = 1;
   */
  mode: Mode;

  /**
   * The email types to block. This may be one or more of the `EmailType`
   * values.
   *
   * @generated from field: repeated proto.decide.v1alpha1.EmailType block = 2 [deprecated = true];
   * @deprecated
   */
  block: EmailType[];

  /**
   * @generated from field: bool require_top_level_domain = 3;
   */
  requireTopLevelDomain: boolean;

  /**
   * @generated from field: bool allow_domain_literal = 4;
   */
  allowDomainLiteral: boolean;

  /**
   * @generated from field: repeated proto.decide.v1alpha1.EmailType allow = 5;
   */
  allow: EmailType[];

  /**
   * @generated from field: repeated proto.decide.v1alpha1.EmailType deny = 6;
   */
  deny: EmailType[];

  /**
   * The version of the rule being executed. This is incremented by SDKs when
   * a breaking change is made to the configuration or behavior of the rule.
   *
   * @generated from field: proto.decide.v1alpha1.EmailRuleVersion version = 7;
   */
  version: EmailRuleVersion;
};

/**
 * Describes the message proto.decide.v1alpha1.EmailRule.
 * Use `create(EmailRuleSchema)` to create a new message.
 */
export declare const EmailRuleSchema: GenMessage<EmailRule>;

/**
 * The configuration for a detect sensitive info rule.
 *
 * @generated from message proto.decide.v1alpha1.SensitiveInfoRule
 */
export declare type SensitiveInfoRule = Message<"proto.decide.v1alpha1.SensitiveInfoRule"> & {
  /**
   * @generated from field: proto.decide.v1alpha1.Mode mode = 1;
   */
  mode: Mode;

  /**
   * The sensitive info types to allow and deny.
   *
   * @generated from field: repeated string allow = 2;
   */
  allow: string[];

  /**
   * @generated from field: repeated string deny = 3;
   */
  deny: string[];

  /**
   * The version of the rule being executed. This is incremented by SDKs when
   * a breaking change is made to the configuration or behavior of the rule.
   *
   * @generated from field: proto.decide.v1alpha1.SensitiveInfoRuleVersion version = 4;
   */
  version: SensitiveInfoRuleVersion;
};

/**
 * Describes the message proto.decide.v1alpha1.SensitiveInfoRule.
 * Use `create(SensitiveInfoRuleSchema)` to create a new message.
 */
export declare const SensitiveInfoRuleSchema: GenMessage<SensitiveInfoRule>;

/**
 * The configuration for a shield rule.
 *
 * @generated from message proto.decide.v1alpha1.ShieldRule
 */
export declare type ShieldRule = Message<"proto.decide.v1alpha1.ShieldRule"> & {
  /**
   * @generated from field: proto.decide.v1alpha1.Mode mode = 1;
   */
  mode: Mode;

  /**
   * @generated from field: bool auto_added = 2;
   */
  autoAdded: boolean;

  /**
   * Defines how Arcjet will track suspicious requests. If none are specified,
   * it will default to using the client IP address. If more than one
   * characteristic is provided, they will be combined. For further details,
   * see https://docs.arcjet.com/architecture/#fingerprinting
   *
   * @generated from field: repeated string characteristics = 3;
   */
  characteristics: string[];

  /**
   * The version of the rule being executed. This is incremented by SDKs when
   * a breaking change is made to the configuration or behavior of the rule.
   *
   * @generated from field: proto.decide.v1alpha1.ShieldRuleVersion version = 4;
   */
  version: ShieldRuleVersion;
};

/**
 * Describes the message proto.decide.v1alpha1.ShieldRule.
 * Use `create(ShieldRuleSchema)` to create a new message.
 */
export declare const ShieldRuleSchema: GenMessage<ShieldRule>;

/**
 * The configuration for a filter rule.
 *
 * @generated from message proto.decide.v1alpha1.FilterRule
 */
export declare type FilterRule = Message<"proto.decide.v1alpha1.FilterRule"> & {
  /**
   * @generated from field: proto.decide.v1alpha1.Mode mode = 1;
   */
  mode: Mode;

  /**
   * @generated from field: repeated string allow = 2;
   */
  allow: string[];

  /**
   * @generated from field: repeated string deny = 3;
   */
  deny: string[];

  /**
   * The version of the rule being executed. This is incremented by SDKs when
   * a breaking change is made to the configuration or behavior of the rule.
   *
   * @generated from field: proto.decide.v1alpha1.FilterRuleVersion version = 4;
   */
  version: FilterRuleVersion;
};

/**
 * Describes the message proto.decide.v1alpha1.FilterRule.
 * Use `create(FilterRuleSchema)` to create a new message.
 */
export declare const FilterRuleSchema: GenMessage<FilterRule>;

/**
 * The configuration for Arcjet.
 *
 * @generated from message proto.decide.v1alpha1.Rule
 */
export declare type Rule = Message<"proto.decide.v1alpha1.Rule"> & {
  /**
   * @generated from oneof proto.decide.v1alpha1.Rule.rule
   */
  rule: {
    /**
     * @generated from field: proto.decide.v1alpha1.RateLimitRule rate_limit = 1;
     */
    value: RateLimitRule;
    case: "rateLimit";
  } | {
    /**
     * @generated from field: proto.decide.v1alpha1.BotRule bots = 2;
     */
    value: BotRule;
    case: "bots";
  } | {
    /**
     * @generated from field: proto.decide.v1alpha1.EmailRule email = 3;
     */
    value: EmailRule;
    case: "email";
  } | {
    /**
     * @generated from field: proto.decide.v1alpha1.ShieldRule shield = 4;
     */
    value: ShieldRule;
    case: "shield";
  } | {
    /**
     * @generated from field: proto.decide.v1alpha1.SensitiveInfoRule sensitive_info = 5;
     */
    value: SensitiveInfoRule;
    case: "sensitiveInfo";
  } | {
    /**
     * @generated from field: proto.decide.v1alpha1.BotV2Rule bot_v2 = 6;
     */
    value: BotV2Rule;
    case: "botV2";
  } | {
    /**
     * @generated from field: proto.decide.v1alpha1.FilterRule filter = 7;
     */
    value: FilterRule;
    case: "filter";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message proto.decide.v1alpha1.Rule.
 * Use `create(RuleSchema)` to create a new message.
 */
export declare const RuleSchema: GenMessage<Rule>;

/**
 * @generated from message proto.decide.v1alpha1.RuleResult
 */
export declare type RuleResult = Message<"proto.decide.v1alpha1.RuleResult"> & {
  /**
   * The stable, deterministic, and unique identifier of the rule that
   * generated this result.
   *
   * @generated from field: string rule_id = 1;
   */
  ruleId: string;

  /**
   * The rule run state
   *
   * @generated from field: proto.decide.v1alpha1.RuleState state = 2;
   */
  state: RuleState;

  /**
   * The conclusion determined by the rule.
   *
   * @generated from field: proto.decide.v1alpha1.Conclusion conclusion = 3;
   */
  conclusion: Conclusion;

  /**
   * The reason for the conclusion.
   *
   * @generated from field: proto.decide.v1alpha1.Reason reason = 4;
   */
  reason?: Reason;

  /**
   * The duration in seconds this result should be considered valid, also
   * known as time-to-live.
   *
   * @generated from field: uint32 ttl = 5;
   */
  ttl: number;

  /**
   * The fingerprint calculated for this rule, which can be used to cache the
   * result for the amount of time specified by `ttl`.
   *
   * @generated from field: string fingerprint = 6;
   */
  fingerprint: string;
};

/**
 * Describes the message proto.decide.v1alpha1.RuleResult.
 * Use `create(RuleResultSchema)` to create a new message.
 */
export declare const RuleResultSchema: GenMessage<RuleResult>;

/**
 * Details about a request under investigation.
 *
 * @generated from message proto.decide.v1alpha1.RequestDetails
 */
export declare type RequestDetails = Message<"proto.decide.v1alpha1.RequestDetails"> & {
  /**
   * @generated from field: string ip = 1;
   */
  ip: string;

  /**
   * @generated from field: string method = 2;
   */
  method: string;

  /**
   * @generated from field: string protocol = 3;
   */
  protocol: string;

  /**
   * @generated from field: string host = 4;
   */
  host: string;

  /**
   * @generated from field: string path = 5;
   */
  path: string;

  /**
   * @generated from field: map<string, string> headers = 6;
   */
  headers: { [key: string]: string };

  /**
   * @generated from field: bytes body = 7;
   */
  body: Uint8Array;

  /**
   * @generated from field: map<string, string> extra = 8;
   */
  extra: { [key: string]: string };

  /**
   * @generated from field: string email = 9;
   */
  email: string;

  /**
   * The string representing semicolon-separated Cookies for a request.
   *
   * @generated from field: string cookies = 10;
   */
  cookies: string;

  /**
   * The `?`-prefixed string representing the Query for a request. Commonly
   * referred to as a "querystring".
   *
   * @generated from field: string query = 11;
   */
  query: string;
};

/**
 * Describes the message proto.decide.v1alpha1.RequestDetails.
 * Use `create(RequestDetailsSchema)` to create a new message.
 */
export declare const RequestDetailsSchema: GenMessage<RequestDetails>;

/**
 * A decision made about the request under investigation.
 *
 * @generated from message proto.decide.v1alpha1.Decision
 */
export declare type Decision = Message<"proto.decide.v1alpha1.Decision"> & {
  /**
   * The decision ID. This is a unique identifier for the decision which can
   * be used to search for the request details in the Arcjet dashboard.
   *
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * Arcjet's conclusion for the request based on our analysis.
   *
   * @generated from field: proto.decide.v1alpha1.Conclusion conclusion = 2;
   */
  conclusion: Conclusion;

  /**
   * The reason for the decision.
   *
   * @generated from field: proto.decide.v1alpha1.Reason reason = 3;
   */
  reason?: Reason;

  /**
   * The outcome of each rule taken into consideration for the decision.
   *
   * @generated from field: repeated proto.decide.v1alpha1.RuleResult rule_results = 4;
   */
  ruleResults: RuleResult[];

  /**
   * The duration in seconds this decision should be considered valid, also
   * known as time-to-live.
   *
   * @generated from field: uint32 ttl = 5;
   */
  ttl: number;

  /**
   * Details about the IP address that informed our conclusion.
   *
   * @generated from field: proto.decide.v1alpha1.IpDetails ip_details = 6;
   */
  ipDetails?: IpDetails;
};

/**
 * Describes the message proto.decide.v1alpha1.Decision.
 * Use `create(DecisionSchema)` to create a new message.
 */
export declare const DecisionSchema: GenMessage<Decision>;

/**
 * A request to the decide API.
 *
 * @generated from message proto.decide.v1alpha1.DecideRequest
 */
export declare type DecideRequest = Message<"proto.decide.v1alpha1.DecideRequest"> & {
  /**
   * @generated from field: proto.decide.v1alpha1.SDKStack sdk_stack = 1;
   */
  sdkStack: SDKStack;

  /**
   * @generated from field: string sdk_version = 2;
   */
  sdkVersion: string;

  /**
   * The information provided via an SDK about a request under investigation.
   *
   * @generated from field: proto.decide.v1alpha1.RequestDetails details = 4;
   */
  details?: RequestDetails;

  /**
   * The rules that are being considered for this request.
   *
   * @generated from field: repeated proto.decide.v1alpha1.Rule rules = 5;
   */
  rules: Rule[];

  /**
   * The characteristics that should be used for fingerprinting.
   *
   * @generated from field: repeated string characteristics = 6;
   */
  characteristics: string[];
};

/**
 * Describes the message proto.decide.v1alpha1.DecideRequest.
 * Use `create(DecideRequestSchema)` to create a new message.
 */
export declare const DecideRequestSchema: GenMessage<DecideRequest>;

/**
 * A response from the decide API.
 *
 * @generated from message proto.decide.v1alpha1.DecideResponse
 */
export declare type DecideResponse = Message<"proto.decide.v1alpha1.DecideResponse"> & {
  /**
   * The decision made about the request under investigation.
   *
   * @generated from field: proto.decide.v1alpha1.Decision decision = 1;
   */
  decision?: Decision;

  /**
   * Any extra information returned by the Arcjet analysis.
   *
   * @generated from field: map<string, string> extra = 2;
   */
  extra: { [key: string]: string };
};

/**
 * Describes the message proto.decide.v1alpha1.DecideResponse.
 * Use `create(DecideResponseSchema)` to create a new message.
 */
export declare const DecideResponseSchema: GenMessage<DecideResponse>;

/**
 * A request to the Report RPC when SDK has already made a decision locally.
 *
 * @generated from message proto.decide.v1alpha1.ReportRequest
 */
export declare type ReportRequest = Message<"proto.decide.v1alpha1.ReportRequest"> & {
  /**
   * @generated from field: proto.decide.v1alpha1.SDKStack sdk_stack = 1;
   */
  sdkStack: SDKStack;

  /**
   * @generated from field: string sdk_version = 2;
   */
  sdkVersion: string;

  /**
   * The information provided via an SDK about a request under investigation.
   *
   * @generated from field: proto.decide.v1alpha1.RequestDetails details = 4;
   */
  details?: RequestDetails;

  /**
   * The decision reported about the request under investigation.
   *
   * @generated from field: proto.decide.v1alpha1.Decision decision = 5;
   */
  decision?: Decision;

  /**
   * The rules that are were considered for this request.
   *
   * @generated from field: repeated proto.decide.v1alpha1.Rule rules = 6;
   */
  rules: Rule[];

  /**
   * The characteristics that should be used for fingerprinting.
   *
   * @generated from field: repeated string characteristics = 8;
   */
  characteristics: string[];
};

/**
 * Describes the message proto.decide.v1alpha1.ReportRequest.
 * Use `create(ReportRequestSchema)` to create a new message.
 */
export declare const ReportRequestSchema: GenMessage<ReportRequest>;

/**
 * A response from the Report RPC.
 *
 * @generated from message proto.decide.v1alpha1.ReportResponse
 */
export declare type ReportResponse = Message<"proto.decide.v1alpha1.ReportResponse"> & {
  /**
   * Any extra information returned by the Arcjet analysis.
   *
   * @generated from field: map<string, string> extra = 2;
   */
  extra: { [key: string]: string };
};

/**
 * Describes the message proto.decide.v1alpha1.ReportResponse.
 * Use `create(ReportResponseSchema)` to create a new message.
 */
export declare const ReportResponseSchema: GenMessage<ReportResponse>;

/**
 * Represents whether we think the client is a bot or not. This should be used
 * alongside the bot score which represents the level of certainty of our
 * detection.
 *
 * @generated from enum proto.decide.v1alpha1.BotType
 */
export enum BotType {
  /**
   * The bot type is unspecified. This should not be used, but is here to
   * conform to the gRPC best practices.
   *
   * @generated from enum value: BOT_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * We could not analyze the request, perhaps because of insufficient
   * information or because the bot analysis can't be executed in this
   * environment. We do not recommend blocking these requests. Represented by
   * a score of 0.
   *
   * @generated from enum value: BOT_TYPE_NOT_ANALYZED = 1;
   */
  NOT_ANALYZED = 1,

  /**
   * We are sure the request was made by an automated bot. We recommend
   * blocking these requests for paths which are for humans only e.g. login or
   * signup pages, but not blocking for API paths. Represented by a score of
   * 1.
   *
   * @generated from enum value: BOT_TYPE_AUTOMATED = 2;
   */
  AUTOMATED = 2,

  /**
   * We have some evidence that the request was made by an automated bot. The
   * degree of certainty is represented by a score range of 2-29.
   *
   * @generated from enum value: BOT_TYPE_LIKELY_AUTOMATED = 3;
   */
  LIKELY_AUTOMATED = 3,

  /**
   * We don't think this request was made by an automated bot. The degree of
   * certainty is represented by a score range of 30-99.
   *
   * @generated from enum value: BOT_TYPE_LIKELY_NOT_A_BOT = 4;
   */
  LIKELY_NOT_A_BOT = 4,

  /**
   * We are sure the request was made by an automated bot and it is on our
   * list of verified good bots. This is manually maintained by the Arcjet
   * team and includes bots such as monitoring agents and friendly search
   * engine crawlers. In most cases you can allow these requests on public
   * pages, but you may wish to block them for internal or private paths.
   * Represented by a score of 100.
   *
   * @generated from enum value: BOT_TYPE_VERIFIED_BOT = 5;
   */
  VERIFIED_BOT = 5,
}

/**
 * Describes the enum proto.decide.v1alpha1.BotType.
 */
export declare const BotTypeSchema: GenEnum<BotType>;

/**
 * Represents the type of email address submitted.
 *
 * @generated from enum proto.decide.v1alpha1.EmailType
 */
export enum EmailType {
  /**
   * The email type is unspecified. This should not be used, but is here to
   * conform to the gRPC best practices.
   *
   * @generated from enum value: EMAIL_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * The email address is disposable, which means it's registered to a service
   * that allows throwaway email addresses. Although these are sometimes used
   * for privacy, they are also often used for spam signups or fraudulent
   * activity when combined with a transaction e.g. attempting to use a credit
   * card. We recommend blocking these in higher risk scenarios.
   *
   * @generated from enum value: EMAIL_TYPE_DISPOSABLE = 1;
   */
  DISPOSABLE = 1,

  /**
   * The email address is registered to a free email service. These are very
   * common, such as GMail or Yahoo Mail, so we do not recommend blocking
   * these. However, you may wish to flag these for review the first time they
   * attempt a transaction.
   *
   * @generated from enum value: EMAIL_TYPE_FREE = 2;
   */
  FREE = 2,

  /**
   * This email address is registered to a domain name which has no MX records
   * configured. This means it cannot receive email. We recommend blocking
   * these.
   *
   * @generated from enum value: EMAIL_TYPE_NO_MX_RECORDS = 3;
   */
  NO_MX_RECORDS = 3,

  /**
   * This email has no Gravatar attached to the email from
   * https://gravatar.com which makes it slightly less likely to be a valid
   * signup. We recommend using this as part of your own risk scoring or
   * manually reviewing these signups.
   *
   * @generated from enum value: EMAIL_TYPE_NO_GRAVATAR = 4;
   */
  NO_GRAVATAR = 4,

  /**
   * This email was specified in an invalid format.
   *
   * @generated from enum value: EMAIL_TYPE_INVALID = 5;
   */
  INVALID = 5,
}

/**
 * Describes the enum proto.decide.v1alpha1.EmailType.
 */
export declare const EmailTypeSchema: GenEnum<EmailType>;

/**
 * The mode to run in. This can be either `DRY_RUN` or `LIVE`. In `DRY_RUN`
 * mode, all requests will be allowed and you can review what the action would
 * have been from your dashboard. In `LIVE` mode, requests will be allowed,
 * challenged or blocked based on the returned decision.
 *
 * @generated from enum proto.decide.v1alpha1.Mode
 */
export enum Mode {
  /**
   * The mode is unspecified. This should not be used, but is here to conform
   * to the gRPC best practices.
   *
   * @generated from enum value: MODE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * In `DRY_RUN` mode, all requests will be allowed and you can review what
   * the action would have been from your dashboard.
   *
   * @generated from enum value: MODE_DRY_RUN = 1;
   */
  DRY_RUN = 1,

  /**
   * In `LIVE` mode, requests will be allowed, challenged or blocked based on
   * the returned decision.
   *
   * @generated from enum value: MODE_LIVE = 2;
   */
  LIVE = 2,
}

/**
 * Describes the enum proto.decide.v1alpha1.Mode.
 */
export declare const ModeSchema: GenEnum<Mode>;

/**
 * @generated from enum proto.decide.v1alpha1.RuleState
 */
export enum RuleState {
  /**
   * The mode is unspecified. This should not be used, but is here to conform
   * to the gRPC best practices.
   *
   * @generated from enum value: RULE_STATE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * The rule was run and the outcome was taken into consideration for the end
   * decision
   *
   * @generated from enum value: RULE_STATE_RUN = 1;
   */
  RUN = 1,

  /**
   * The rule wasn't run
   *
   * @generated from enum value: RULE_STATE_NOT_RUN = 2;
   */
  NOT_RUN = 2,

  /**
   * The rule was run but not actioned on, meaning the outcome didn't affect
   * the end decision
   *
   * @generated from enum value: RULE_STATE_DRY_RUN = 3;
   */
  DRY_RUN = 3,

  /**
   * The rule was not run because the reason was cached
   *
   * @generated from enum value: RULE_STATE_CACHED = 4;
   */
  CACHED = 4,
}

/**
 * Describes the enum proto.decide.v1alpha1.RuleState.
 */
export declare const RuleStateSchema: GenEnum<RuleState>;

/**
 * The conclusion for the request based on the Arcjet analysis and any specific
 * configuration.
 *
 * @generated from enum proto.decide.v1alpha1.Conclusion
 */
export enum Conclusion {
  /**
   * The conclusion is unspecified. This should not be used, but is here to
   * conform to the gRPC best practices.
   *
   * @generated from enum value: CONCLUSION_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * The request should be allowed.
   *
   * @generated from enum value: CONCLUSION_ALLOW = 1;
   */
  ALLOW = 1,

  /**
   * The request should be blocked.
   *
   * @generated from enum value: CONCLUSION_DENY = 2;
   */
  DENY = 2,

  /**
   * The request should be challenged.
   *
   * @generated from enum value: CONCLUSION_CHALLENGE = 3;
   */
  CHALLENGE = 3,

  /**
   * The request errored.
   *
   * @generated from enum value: CONCLUSION_ERROR = 4;
   */
  ERROR = 4,
}

/**
 * Describes the enum proto.decide.v1alpha1.Conclusion.
 */
export declare const ConclusionSchema: GenEnum<Conclusion>;

/**
 * The SDK used to make the request. Used for analytics and to help us improve.
 *
 * @generated from enum proto.decide.v1alpha1.SDKStack
 */
export enum SDKStack {
  /**
   * @generated from enum value: SDK_STACK_UNSPECIFIED = 0;
   */
  SDK_STACK_UNSPECIFIED = 0,

  /**
   * @generated from enum value: SDK_STACK_NODEJS = 1;
   */
  SDK_STACK_NODEJS = 1,

  /**
   * @generated from enum value: SDK_STACK_NEXTJS = 2;
   */
  SDK_STACK_NEXTJS = 2,

  /**
   * @generated from enum value: SDK_STACK_PYTHON = 3;
   */
  SDK_STACK_PYTHON = 3,

  /**
   * @generated from enum value: SDK_STACK_DJANGO = 4;
   */
  SDK_STACK_DJANGO = 4,

  /**
   * @generated from enum value: SDK_STACK_BUN = 5;
   */
  SDK_STACK_BUN = 5,

  /**
   * @generated from enum value: SDK_STACK_DENO = 6;
   */
  SDK_STACK_DENO = 6,

  /**
   * @generated from enum value: SDK_STACK_SVELTEKIT = 7;
   */
  SDK_STACK_SVELTEKIT = 7,

  /**
   * @generated from enum value: SDK_STACK_HONO = 8;
   */
  SDK_STACK_HONO = 8,

  /**
   * @generated from enum value: SDK_STACK_NUXT = 9;
   */
  SDK_STACK_NUXT = 9,

  /**
   * @generated from enum value: SDK_STACK_NESTJS = 10;
   */
  SDK_STACK_NESTJS = 10,

  /**
   * @generated from enum value: SDK_STACK_REMIX = 11;
   */
  SDK_STACK_REMIX = 11,

  /**
   * @generated from enum value: SDK_STACK_ASTRO = 12;
   */
  SDK_STACK_ASTRO = 12,

  /**
   * @generated from enum value: SDK_STACK_FASTIFY = 13;
   */
  SDK_STACK_FASTIFY = 13,

  /**
   * @generated from enum value: SDK_STACK_REACT_ROUTER = 14;
   */
  SDK_STACK_REACT_ROUTER = 14,
}

/**
 * Describes the enum proto.decide.v1alpha1.SDKStack.
 */
export declare const SDKStackSchema: GenEnum<SDKStack>;

/**
 * @generated from enum proto.decide.v1alpha1.RateLimitAlgorithm
 */
export enum RateLimitAlgorithm {
  /**
   * @generated from enum value: RATE_LIMIT_ALGORITHM_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: RATE_LIMIT_ALGORITHM_TOKEN_BUCKET = 1;
   */
  TOKEN_BUCKET = 1,

  /**
   * @generated from enum value: RATE_LIMIT_ALGORITHM_FIXED_WINDOW = 2;
   */
  FIXED_WINDOW = 2,

  /**
   * @generated from enum value: RATE_LIMIT_ALGORITHM_SLIDING_WINDOW = 3;
   */
  SLIDING_WINDOW = 3,
}

/**
 * Describes the enum proto.decide.v1alpha1.RateLimitAlgorithm.
 */
export declare const RateLimitAlgorithmSchema: GenEnum<RateLimitAlgorithm>;

/**
 * @generated from enum proto.decide.v1alpha1.RateLimitRuleVersion
 */
export enum RateLimitRuleVersion {
  /**
   * This is equivalent to V0 since rules without a version specified will
   * default to this value.
   *
   * @generated from enum value: RATE_LIMIT_RULE_VERSION_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,
}

/**
 * Describes the enum proto.decide.v1alpha1.RateLimitRuleVersion.
 */
export declare const RateLimitRuleVersionSchema: GenEnum<RateLimitRuleVersion>;

/**
 * @generated from enum proto.decide.v1alpha1.BotV2RuleVersion
 */
export enum BotV2RuleVersion {
  /**
   * This is equivalent to V0 since rules without a version specified will
   * default to this value.
   *
   * @generated from enum value: BOT_V2_RULE_VERSION_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,
}

/**
 * Describes the enum proto.decide.v1alpha1.BotV2RuleVersion.
 */
export declare const BotV2RuleVersionSchema: GenEnum<BotV2RuleVersion>;

/**
 * @generated from enum proto.decide.v1alpha1.EmailRuleVersion
 */
export enum EmailRuleVersion {
  /**
   * This is equivalent to V0 since rules without a version specified will
   * default to this value.
   *
   * @generated from enum value: EMAIL_RULE_VERSION_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,
}

/**
 * Describes the enum proto.decide.v1alpha1.EmailRuleVersion.
 */
export declare const EmailRuleVersionSchema: GenEnum<EmailRuleVersion>;

/**
 * @generated from enum proto.decide.v1alpha1.SensitiveInfoRuleVersion
 */
export enum SensitiveInfoRuleVersion {
  /**
   * This is equivalent to V0 since rules without a version specified will
   * default to this value.
   *
   * @generated from enum value: SENSITIVE_INFO_RULE_VERSION_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,
}

/**
 * Describes the enum proto.decide.v1alpha1.SensitiveInfoRuleVersion.
 */
export declare const SensitiveInfoRuleVersionSchema: GenEnum<SensitiveInfoRuleVersion>;

/**
 * @generated from enum proto.decide.v1alpha1.ShieldRuleVersion
 */
export enum ShieldRuleVersion {
  /**
   * This is equivalent to V0 since rules without a version specified will
   * default to this value.
   *
   * @generated from enum value: SHIELD_RULE_VERSION_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,
}

/**
 * Describes the enum proto.decide.v1alpha1.ShieldRuleVersion.
 */
export declare const ShieldRuleVersionSchema: GenEnum<ShieldRuleVersion>;

/**
 * @generated from enum proto.decide.v1alpha1.FilterRuleVersion
 */
export enum FilterRuleVersion {
  /**
   * This is equivalent to V0 since rules without a version specified will
   * default to this value.
   *
   * @generated from enum value: FILTER_RULE_VERSION_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,
}

/**
 * Describes the enum proto.decide.v1alpha1.FilterRuleVersion.
 */
export declare const FilterRuleVersionSchema: GenEnum<FilterRuleVersion>;

/**
 * @generated from service proto.decide.v1alpha1.DecideService
 */
export declare const DecideService: GenService<{
  /**
   * @generated from rpc proto.decide.v1alpha1.DecideService.Decide
   */
  decide: {
    methodKind: "unary";
    input: typeof DecideRequestSchema;
    output: typeof DecideResponseSchema;
  },
  /**
   * @generated from rpc proto.decide.v1alpha1.DecideService.Report
   */
  report: {
    methodKind: "unary";
    input: typeof ReportRequestSchema;
    output: typeof ReportResponseSchema;
  },
}>;

